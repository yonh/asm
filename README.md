
# 第7章
## and和or
如果想要某一位变为0,利用0与其进行与运算  
如果想要某一位变为1,利用1与其进行或运算  
1111 and 1011 => 1011  
0000 or 0100  => 0100  

## 大小写转换的问题
* 将大写+20h可转换为小写, 将小写-20h可转换为大写
* 利用and或or运算,更改第五位(索引从0开始), 要获得大写改为0, 要获得小写则改为1

## 内存寻址
* [bx+idata]
* 


# 第8章
### 关于偏移地址的表示
* 在8086CPU中，能够用于偏移地址的寄存器只有 bx, si, di, bp  
* 在表示偏移地址的组合中，只有bx和si, bx和di, bp和si, bp和di这四种组合  
* 如果使用了bp而又没有显式的给出段地址,那么段地址就是ss, 如  
	mov ax, [bp]		<=>		mov ax, ss:[bp]  
	mov ax, [bp+idata]	<=>		mov ax, ss:[bp+idata]  

## 寻址方式总结
* 直接寻址
* 寄存器间接寻址
* 寄存器相对寻址
* 基址变址寻址
* 相对基址变址寻址

## 处理的数据的长度是多少
* 如果使用到具体寄存器，则操作数据的大小等同于寄存器
* 没有寄存器的情况下可使用X ptr表示，X可为word，byte
* 其他，如push操作数据的大小只能是word

mov word ptr ds:[0], 1  
mov byte ptr ds:[0], 1  



## div
```asm
; div reg / div [...]
div ax
div byte ptr ds:[0]
```
div是一个除法指令，除法指令执行我们需要知道的信息有
* 除数的大小(8/16位)
* 被除数的最大值
* 被除数在哪
* 商被保存在哪
* 余数被保存在哪
* 被除数比除数大一倍， 若除数是8位，被除数则为16位

| 除数的大小  |   被除数      | 商 | 余数 |
|-------------|---------------|----|------|
|    8位      |     AX        | AL |  AH  |
|   16位      | DX(高),AX(低) | AX |  DX  |


> 使用div计算的时候需要注意,不能让商溢出, 8位除数商最大值为255, 16位除数商最大值65535
> 对应的被除数最大值为65279(FEFF 8位), 4294901759(FFFE FFFF 16位)


程序示例  
除数为8位: 8_div_8.asm
除数为16位: 8_div_16.asm

```asm
div byte ptr [0]
(al) = (ax) / ((ds)*16 + 0)的商
(ah) = (ax) / ((ds)*16 + 0)的余数

div word ptr [0]
(ax) = (ds)*10000h + (ax) / ((ds) * 16 + 0)的商
(dx) = (ds)*10000h + (ax) / ((ds) * 16 + 0)的余数
```

## db,dw和dd
db: 定义字节数据, 每个占一个字节  
dw: 定义字数据,   每个占两个字节  
dd: 定义双字数据, 每个占四个字节  	

## dup
配合db,dw,dd使用,定义连续n个相同的数据
```asm
db 重复次数 dup (重复的字节型数据)
dw 重复次数 dup (重复的字型数据)
dd 重复次数 dup (重复的双字型数据)
```

# 第9章
## 本章总结
* 只要是段内转移,并不包含真实地址,只是通过偏移量跳转
* 所有的有条件转移指令都是短转移,对IP的修改范围-128~127
* 所有的循环指令都是短转移, 对IP的修改范围为-128~127
* 位移距离使用补码表示

## 转移指令汇总
* jmp		无条件跳转
* jcxz		cx为零则跳转
* loop		cx不等于0则跳转
* je		等于则跳转 (zf=1)
* jne		不等于则跳转 (zf=0)
* jb		低于则跳转 (cf=1)
* jnb		不低于则跳转 (cf=0)
* ja		高于则跳转 (cf=0且zf=0)
* jna		不高于则跳转 (cf=1或zf=1)

## 几个名词记录
```
## 短转移
不包含目的地地址, 只是获得转移的位移,只修改IP, 范围-128~127

```
## 转移指令
可以修改IP或同时修改CS和IP的指令统称为转移指令
8086CPU的转移指令分为以下几类
* 无条件转移(如jmp)
* 条件转移
* 循环 (loop)
* 过程
* 中断

## offset
offset的作用是获取标号的偏移地址  
```asm
start: mov ax, offset s ; 获取标号s的偏移地址,送入ax
end: mov ax, offset end ; 获取标号end的偏移地址,送入ax
```

## 回顾指令执行步骤
1. 从CS:IP指向的单元读取指令到指令缓冲器
2. IP = IP+指令的长度
3. 执行指令, 回到第一步重复这个过程

## jmp指令
修改CS:IP或IP使程序跳转都某处开始执行代码

## 转移位移的计算方法
位移 = 标号位置 - jmp指令的下一条指令的位置

```asm
; 几条转移指令
jmp 标号
jmp short 标号 		; 8位位移 (范围-128~127)
jmp near ptr 标号 	; 此处的位移是16位 (范围-32768~32767)
jmp far ptr 标号	; 实现段间转移, (不存在转移范围只能是 -32768~32767的问题)
jmp 寄存器			; IP = 寄存器的值
jmp word ptr 内存单元地址  ; 段内转移
jmp dword ptr 内存单元地址 ; 段间转移, 高位存储段地址, 低位存储偏移地址
jcxz 标号 			; jmp if cx is zero的缩写(我猜),用C表示就是 if (0==cx) jmp short 标号

```


## 使用汇编显示字符
在内存地址中B8000~BFFFF,共32kib的空间为80x25(列x行)彩色字符模式的显示缓冲区,在这里写入数据将会显示出来  
每个字符占2个字节,分别是字符的ASCII码(低位), 字符的属性(高位)  

字符的属性有: 前景色,背景色,闪烁,高亮, (闪烁的效果必须在DOS全屏的方式才能看到?)

|闪烁| 背景 | 高亮 |  前景  |
|----|------|------|--------|
| BL | R G  B | I | R  G  B |
| 7 | 6  5  4 | 3 | 2  1  0 |



# 第10章
## 本章总结
* ret  =>  pop ip
* retf =>  pop ip, pop cs
* call不能实现短转移
* 子程序中使用了寄存器,可能主程序也使用了,从而造成寄存器冲突
## ret和retf
ret指令利用栈实现修改IP的值，从而实现近转移  
retf利用栈实现修改CS和IP的值，从而实现远转移  
```asm
; 执行ret的时候
(ip) = ((ss)*16+ (sp))
(sp) = (sp)+2
; 相当于汇编指令
pop ip


; 执行retf的时候
(ip) = ((ss)*16 + (sp))
(sp) = (sp)+2
(cs) = ((ss)*16 + (sp))
(sp) = (sp)+2
; 相当于汇编指令
pop ip
pop cs 
```

## call
执行call会将下一条指令的IP或CS:IP入栈,然后跳转  
需要关注call后的参数,会导致IP或CS:IP入栈

### 几种调用call的例子
* call 标号
* callfar ptr 标号
* call 16位寄存器
* call word ptr 内存单元地址
* call dword ptr 内存单元地址

### call指令执行段内转移过程
1. 将call指令的下一条指令压栈
2. 程序跳转到标号处执行
用汇编解释  
push ip  
jmp near ptr 标号  

### call指令执行段间转移过程
1. 将call指令的下一条指令的CS压栈
2. 将call指令的下一条指令的IP压栈
3. 跳转到标号处执行
用汇编解释  
push cs  
push ip  
jmp far ptr 标号  

# mul乘法指令
和除法指令相同,乘法指令需要用到ax和dx,同时2个数需要同时是8位或16位  
若是8位,则一个数存放在al,另一个数存放在8位寄存器或内存单元中, 结果存于ax  
若是16位,则一个数存放在ax,另一个数存放在16位寄存器或内存单元中,结果存于ax(低位)和dx(高位)中  
```asm
; 格式如下
; mul 寄存器
; mul 内存单元

mul byte ptr ds:[0]
mul word ptr ds:[0]
mul bl
mul bx
```

# 第11章
本章讲了关于标志寄存器的相关内容  
标志寄存器位置  
|15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
|  |  |  |  |of|df|if|tf|sf|zf|  |af|  |pf|  |cf|
debug中标志位的值
|flag| =1 | =0 |
| of | OV | NV |
| of | NG | PL |
| of | ZR | NZ |
| of | PE | PO |
| of | CY | NC |
| of | DN | UP |

## 本章总结
* 影响标志寄存器的大多是运算指令,如add,sub,div

## ZF
zf是零标志位,当操作的结果为0时,zf位的值为1
在8086CPU中，有的指令会影响标志寄存器,如add,sub,mul,div,inc,or,and  
有的指令对标志寄存器没有影响,如mov,push,pop  

## PF
pf是奇偶标志位,它记录了相关指令执行后,如果其而2进制值中的1的个数为偶数,则pf=1

## SF
sf是符号标志位,它记录了相关指令执行后,如果其结果为负数,则sf=1

## CF
cf是进位标志位,当进行无符号运算过程中产生了进位或者借位,则cf=1

## OF
在进行有符号运算产生溢出,of=1

## DF
df是方向标志位,可在串处理指令中操作di,si的增减  
```asm
; 相关指令参考
cld			; df=0,正向传送
std			; df=1,逆向传送
rep movsb	;每次传送byte, di,si步长=1, 用汇编描述就是 => 1.mov di:[si], byte ptr di:[di] 2. inc si    3. inc di   
; rep movsb等价于 (描述用语)
s:
	mov [si], byte ptr [di]
	inc di
	inc si
loop s

rep movsw	;每次传送word, di,si步长=2, 用汇编描述就是 => 1.mov di:[si], byte ptr di:[di] 2. add si,2  3. add di,2   
; rep movsw等价于 (描述用语)
s:
	mov [si], word ptr [di]
	add si, 2
	add di, 2
loop s

```

## adc指令
加法指令,和add不同的是会加上cf的值, adc ax, bx => ax = ax + bx + cf

## sbb指令
减法指令,和sub不同的是会减去cf的值, sbb ax, bx => ax = ax - bx - cf

## cmp
cmp指令通过减法运算(不保存结果),影响标志寄存器的值,通过标志寄存器的值可得出相关对象的关系  
如cmp ax, bx (无符号比较)
* if ax=bx,  zf=1
* if ax!=bx, zf=0
* if ax<bx,  cf=1
* if ax<=bx, cf=1 || zf=1
* if ax>=bx, cf=0
* if ax>bx,  cf=0 && zf=0

如cmp ax, bx (有符号比较)
* if ax=bx,  zf=1
* if ax>bx,	 sf=1 && of=1
* if ax<bx,  (sf=1 && of=0) || (sf=0 && of=1)
* if ax>=bx, sf=0 && of=0
关于上面的详细证明查看书本的p222~p225  

## pushf和popf
pushf和popf是针对标志寄存器的入栈和出栈操作  
```asm
; pushf和popf让访问标志寄存器中的数据提供了可能
pushf
pop ax		; 将标志寄存器的值送入ax
```

# 12章
## 本章总结
* 什么是中断
* 什么是中断向量表
* 中断过程和iret指令
* 中断的4种情况
* 单步中断
* 响应中断的特殊情况

## 什么是中断
CPU在执行程序的过程中,接收到的一种特殊请求,会暂停当前的操作,转而处理该特殊请求,完成后再继续执行,我们称之为中断  
CPU接收的中断信息必须包含一个字节的中断类型码,
## 中断的4种情况
* 除法错误(0)
* 单步执行(1)
* 执行into指令(4)
* 执行int指令 (int n)

## 什么是中断向量表
中断向量表即是记录了中断处理程序地址的列表,其位于内存地址0:0~0:3FF中  
一个表项的大小是4个字节,高位存储短地址,低位存储偏移地址

## 中断过程和iret指令
CPU通过中断类型码找到中断向量,并设置CS和IP,整个过程便是中断过程,由CPU自动完成  
中断过程:
1. 从中断信息获取中断类型码
2. 标志寄存器入栈
3. 设置标志寄存器TF,IF = 0
4. CS入栈
5. IP入栈
6. CS:IP指向中断处理程序, IP=中断类型码*4, CS=中断类型码*4+2

用汇编描述就是  
1. 获取类型码
2. pushf
3. TF=0, IF=0
4. push cs
5. push ip
6. ip = 中断类型码*4, cs=中断类型码*4+2

从某种角度上看, 中断和子程序的整个过程都是类似的  

iret和ret比较像,仅仅多了个pushf,用汇编描述:  
```asm
pop ip
pop cs
popf
```

## 单步中断
当CPU执行完一条指令后发现TF=1,则产生单步中断(类型码=1)  
也因为如此,所以中断过程需要将设置TF=0, 防止CPU无限执行1号中断操作  

## 不响应中断的特殊情况
在一般情况下,CPU在执行完一条指令,如果发生中断,会马上执行中断  
但在有些情况下,即便是发生了中断,CPU也不响应,我们可以测试下面的代码
```
	mov ax, 1
	mov ss, ax
	int 21h		; cpu不响应
	int 21h		; cpu不响应
	mov ax, 4c00h ; 当执行mov ss, ax后这条指令就被接着执行
	int 21h
```

修改ss不响应中断的原因是,当修改ss的时候,如果处理中断,那么需要将标志寄存器,cs,ip入栈,这样造成了指向了错误的栈顶位置,导致错误  
因此我们需要将对ss和sp的修改放在一起连续执行


# 关于寄存器的大小问题
一个寄存器通常是16位,如: al(8),ah(8) => ax(16)  
al, ah的存值范围 0-255	=> 1个字节	=> 8个二进制数  
ax的存值范围 0-65535	=> 2个字节	=> 16个二进制数  

用16进制表示则是  
al的范围是0-ff  
ax的范围是0-ffff  

